"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertGrpcRecord = exports.convertPersistentSubscriptionGrpcEvent = exports.convertGrpcEvent = void 0;
const debug_1 = require("./debug");
const _1 = require(".");
const convertGrpcEvent = (grpcEvent) => {
    const resolved = {};
    if (grpcEvent.hasEvent()) {
        resolved.event = (0, exports.convertGrpcRecord)(grpcEvent.getEvent());
    }
    if (grpcEvent.hasLink()) {
        resolved.link = (0, exports.convertGrpcRecord)(grpcEvent.getLink());
    }
    if (grpcEvent.hasCommitPosition()) {
        resolved.commitPosition = BigInt(grpcEvent.getCommitPosition());
    }
    return resolved;
};
exports.convertGrpcEvent = convertGrpcEvent;
const convertPersistentSubscriptionGrpcEvent = (grpcEvent) => {
    const resolved = {
        retryCount: grpcEvent.hasRetryCount() ? grpcEvent.getRetryCount() : 0,
    };
    if (grpcEvent.hasEvent()) {
        resolved.event = (0, exports.convertGrpcRecord)(grpcEvent.getEvent());
    }
    if (grpcEvent.hasLink()) {
        resolved.link = (0, exports.convertGrpcRecord)(grpcEvent.getLink());
    }
    if (grpcEvent.hasCommitPosition()) {
        resolved.commitPosition = BigInt(grpcEvent.getCommitPosition());
    }
    return resolved;
};
exports.convertPersistentSubscriptionGrpcEvent = convertPersistentSubscriptionGrpcEvent;
const extractPosition = (grpcRecord) => {
    const commit = grpcRecord.getCommitPosition();
    const prepare = grpcRecord.getPreparePosition();
    if (commit != null && prepare != null) {
        return {
            commit: BigInt(commit),
            prepare: BigInt(prepare),
        };
    }
    return undefined;
};
const safeParseJSON = (str, fallback, errorMessage) => {
    try {
        const parsed = JSON.parse(str);
        return parsed;
    }
    catch (error) {
        debug_1.debug.events(errorMessage);
        return fallback(str);
    }
};
const parseMetadata = (grpcRecord, id) => {
    const metadata = grpcRecord.getCustomMetadata_asU8();
    if (!metadata.length)
        return;
    try {
        return JSON.parse(Buffer.from(metadata).toString("utf8"));
    }
    catch (error) {
        return metadata;
    }
};
const TICKS_PER_MILLISECOND = BigInt(10000);
const convertCreatedToDate = (created, id) => {
    // Created should always be present, but we'll default to `0` just in case.
    if (created == null) {
        debug_1.debug.events(`Missing "created" in event ${id}`);
        return new Date(0);
    }
    try {
        // Created is in dotnet "ticks", which are 100 nanoseconds.
        const millisecondsSinceEpoch = BigInt(created) / TICKS_PER_MILLISECOND;
        // We need to convert to a number to create a Date.
        // An ECMAScript Date can only go up to 8.64e15, so this should be safe to do until the year 275760.
        // https://262.ecma-international.org/10.0/#sec-time-values-and-time-range
        const epoch = Number(millisecondsSinceEpoch);
        return new Date(epoch);
    }
    catch (error) {
        debug_1.debug.events(`Invalid "created" in event ${id}. ${error.message}`);
        return new Date(0);
    }
};
const convertGrpcRecord = (grpcRecord) => {
    var _a, _b;
    const metadataMap = grpcRecord.getMetadataMap();
    const type = (_a = metadataMap.get("type")) !== null && _a !== void 0 ? _a : "<no-event-type-provided>";
    const contentType = (_b = metadataMap.get("content-type")) !== null && _b !== void 0 ? _b : "application/octet-stream";
    if (!grpcRecord.hasStreamIdentifier()) {
        throw "Impossible situation where streamIdentifier is undefined in a recorded event";
    }
    const streamId = Buffer.from(grpcRecord.getStreamIdentifier().getStreamName()).toString("utf8");
    if (!grpcRecord.hasId()) {
        throw "Impossible situation where id is undefined in a recorded event";
    }
    const id = (0, _1.parseUUID)(grpcRecord.getId());
    const created = convertCreatedToDate(metadataMap.get("created"), id);
    const revision = BigInt(grpcRecord.getStreamRevision());
    const metadata = parseMetadata(grpcRecord, id);
    const isJson = contentType === "application/json";
    const position = extractPosition(grpcRecord);
    if (isJson) {
        const dataStr = Buffer.from(grpcRecord.getData()).toString("utf8");
        const data = safeParseJSON(dataStr, (d) => d, `Malformed JSON data in event ${id}`);
        return {
            streamId,
            id,
            revision,
            type,
            data,
            metadata,
            isJson,
            created,
            position,
        };
    }
    const data = grpcRecord.getData_asU8();
    return {
        streamId,
        id,
        revision,
        type,
        data,
        metadata,
        isJson,
        created,
        position,
    };
};
exports.convertGrpcRecord = convertGrpcRecord;
